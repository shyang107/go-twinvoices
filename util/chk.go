package util

import (
	"fmt"
	"path"
	"runtime"
	"strings"

	"github.com/fatih/color"
)

// Panic panicks
func Panic(msg string, prm ...interface{}) {
	CallerInfo(4)
	CallerInfo(3)
	CallerInfo(2)
	panic(fmt.Sprintf(msg, prm...))
}

// CallerInfo returns the file and line positions where an error occurred
//  idx -- use idx=2 to get the caller of Panic
func CallerInfo(idx int) {
	pc, file, line, ok := runtime.Caller(idx)
	if !ok {
		file, line = "?", 0
	}
	var fname string
	f := runtime.FuncForPC(pc)
	if f != nil {
		fname = f.Name()
	}
	if Verbose {
		// fmt.Printf("file = %s:%d\n", file, line)
		// fmt.Printf("func = %s\n", fname)
		fmt.Printf("file = %s:%d -- func = %s\n", file, line, fname)
	}
}

// GetErrMessage get error message if error
func GetErrMessage(err error) string {
	if err != nil {
		return fmt.Sprintf("Error is :'%s'", err.Error())
	}
	return "Notfound this error"
}

// CheckErr check error
func CheckErr(err error) {
	if err != nil {
		// perr(getErrMessage(err))
		panic(err)
	}
}

// FuncCallerInfo describes the information of callers of function
type FuncCallerInfo struct {
	packageName string
	fileName    string
	funcName    string
	line        int
}

// RetrieveCallerInfo retrieve the information of callers of function
func RetrieveCallerInfo(idx int) *FuncCallerInfo {
	pc, file, line, _ := runtime.Caller(idx)
	_, fileName := path.Split(file)
	parts := strings.Split(runtime.FuncForPC(pc).Name(), ".")
	pl := len(parts)
	packageName := ""
	funcName := parts[pl-1]

	if parts[pl-2][0] == '(' {
		funcName = parts[pl-2] + "." + funcName
		packageName = strings.Join(parts[0:pl-2], ".")
	} else {
		packageName = strings.Join(parts[0:pl-1], ".")
	}

	return &FuncCallerInfo{
		packageName: packageName,
		fileName:    fileName,
		funcName:    funcName,
		line:        line,
	}
}

// CallerName return the name of function calling
func CallerName(idx int) string {
	// pc, _, _, _ := runtime.Caller(idx) //idx = 0 self, 1 for caller, 2 for upper caller
	// msg := runtime.FuncForPC(pc).Name()
	ci := RetrieveCallerInfo(idx + 1)
	if ci.fileName == "<autogenerated>" {
		return Sf("package: %s:%d; func = %s", ci.packageName, ci.line, ci.funcName)
	}
	return Sf("file: %s:%d; func = %s", ci.fileName, ci.line, ci.funcName)
}

// Startfunc print the message at the start of function
func Startfunc(fid int) {
	Pfstart(Format[fid], CallerName(2))
}

// Stopfunc print the message at the start of function
func Stopfunc(fid int) {
	Pfstop(Format[fid], CallerName(2))
	PrintSepline(60)
}

// DebugPrintCaller print the name of function called and calling
func DebugPrintCaller() {
	// msg := Sf("▶ %q called by %q", CallerName(2), CallerName(3))
	// Glog.Debug(msg)
	if glog.Printer.IsTerminal {
		Glog.Debugf("▶ [%s] called by [%s]",
			color.HiYellowString(CallerName(2)), color.YellowString(CallerName(3)))
	} else {
		Glog.Debugf("▶ [%s] called by [%s]", CallerName(2), CallerName(3))
	}
}
